# nonconvex_newt_surrogate.py is a toy wrapper to illustrate the path
# taken by Hessian descent (or Newton's method).  The steps are evaluated
# at the objective, and then plotted.  For the first 5 iterations the
# quadratic surrogate used to transition from point to point is also plotted.
# The plotted points on the objective turn from green to red as the
# algorithm converges (or reaches a maximum iteration count, preset to 50).
# The (nonconvex) function here is
#
#g(w) = exp(w)*cos(2pi*sin(pi*w))
#
# This file pairs with chapter 2 of the textbook "Machine Learning Refined" published by Cambridge University Press, 
# free for download at www.mlrefined.com

import numpy as np
import matplotlib.pyplot as plt
import time

# define the cost function
def obj(y):
    z = np.exp(y)*np.cos(2*np.pi*np.sin(np.pi*y))
    return z

# define the gradient of the cost function
def grad(y):
    z = np.exp(y)*np.cos(2*np.pi*np.sin(np.pi*y)) - 2*(np.pi**2)*np.exp(y)*np.sin(2*np.pi*np.sin(np.pi*y))*np.cos(np.pi*y)
    return z

# define the hessian / 2nd derivative at each step
def hess(y):
    z = np.exp(y)*(2*(np.pi**3)*np.sin(np.pi*y)*np.sin(2*np.pi*np.sin(np.pi*y)) - (4*np.pi**4)*(np.cos(np.pi*y)**2)*np.cos(2*np.pi*np.sin(np.pi*y)) + np.cos(2*np.pi*np.sin(np.pi*y)) - (4*np.pi**2)*np.sin(2*np.pi*np.sin(np.pi*y))*np.cos(np.pi*y))
    return z

# define the quadratic surrogate generated by Newton's method at each step
def surrogate(y,x):
    a = hess(y)
    z = obj(y) + grad(y)*(x - y) + 0.5*hess(y)*(x - y)*(x - y)
    return z,a


# Newton's method function
def newtons_method(w0):
    #initializations
    grad_stop = 10**-3
    max_its = 50
    iter = 1
    grad_eval = 1
    g_path = []
    w_path = []
    w_path.append(w0)
    g_path.append(obj(w0))
    w = w0
    #main loop
    while np.linalg.norm(grad_eval) > grad_stop and iter <= max_its:
        #take gradient step
        grad_eval = grad(w)
        hess_eval = hess(w)
        w = w - grad_eval/(hess_eval + 10**-4)

        #update containers
        w_path.append(w)
        g_path.append(np.exp(w)*np.cos(2*np.pi*np.sin(np.pi*w)))

        #update stopers
        iter+= 1
    return w,w_path, g_path

# plot the cost function
def make_function():
    # plot the function
    global fig,ax1
    fig = plt.figure(facecolor = 'white')
    ax1 = fig.add_subplot(111)
    s = np.linspace(0,1.1,2000)
    t =  np.exp(s)*np.cos(2*np.pi*np.sin(np.pi*s))
    ax1.plot(s,t,'-k',linewidth = 2)

    # pretty the figure up
    ax1.set_xlim(0,1.1)
    ax1.set_ylim(-5,5)
    ax1.set_xlabel('$w$',fontsize=20,labelpad = 20)
    ax1.set_ylabel('$g(w)$',fontsize=20,rotation = 0,labelpad = 20)

# plot each step
def plot_steps_with_surrogate(w_path,g_path):
    #colors for points
    s = np.linspace(1/len(g_path),1,len(g_path))
    s.shape = (len(s),1)
    colorspec = np.concatenate((s,np.flipud(s)),1)
    colorspec = np.concatenate((colorspec,np.zeros((len(s),1))),1)

    #plot initial point
    ax1.plot(w_path[0],g_path[0],'o',markersize = 9, color = colorspec[0,:], markerfacecolor = colorspec[0,:])
    plt.draw()
    # ax1.annotate('$w$'+str(0),(w_path[0],-5))
    t = np.linspace(-5,g_path[0],100)
    s = w_path[0]*np.ones((100))
    ax1.plot(s,t,'--k')
    plt.draw()
    time.sleep(2)

    #plot first quadratic and point traveled to
    s_range = 5
    s = np.linspace(w_path[0]-s_range,w_path[0]+s_range,10000)
    t,a = surrogate(w_path[0],s)
    h, = ax1.plot(s,t,'--m')
    if a>0:
        ind = np.argmin(t)
    if a<0:
        ind = np.argmax(t)
    x_mark, = ax1.plot(s[ind],t[ind],'ko',markersize = 6)
    plt.draw()

    for i in range(1,len(g_path)):
            if i <= 3:
                time.sleep(2.5)

                #plot point
                ax1.plot(w_path[i],g_path[i],'o',markersize = 9, color = colorspec[i-1,:], markerfacecolor = colorspec[i-1,:])
                plt.draw()

                # remove old point and quadratic
                time.sleep(1)
                h.remove()
                x_mark.remove()
                plt.draw()

                # plot quadratic approximation
                s_range = 5
                s = np.linspace(w_path[i]-s_range,w_path[i]+s_range,10000)
                t,a = surrogate(w_path[i],s)
                time.sleep(1)
                h, = ax1.plot(s,t,'--m')
                if a>0:
                    ind = np.argmin(t)
                if a<0:
                    ind = np.argmax(t)

                # plot stationary pt of quadratic
                x_mark, = ax1.plot(s[ind],t[ind],'ko',markersize = 6)
                plt.draw()

            if i == 3:
                # remove quadratic and pt
                time.sleep(1)
                h.remove()
                x_mark.remove()
                plt.draw()

            if i >=3: # just plot point so things don't get too cluttered
                time.sleep(0.06)
                ax1.plot(w_path[i],g_path[i],'o',markersize = 9, color = colorspec[i-1,:], markerfacecolor = colorspec[i-1,:])
                plt.draw()
            # if i == len(g_path) - 1:
            #     h.remove()
            #     x_mark.remove()
            #     time.sleep(1.5)
            #     # ax1.annotate('$w$'+str(i),(w_path[i],-5))
            #     t = linspace(-5,g_path[i],100)
            #     s = w_path[i]*ones((100))
            #     ax1.plot(s,t,'--k')
    plt.show(True)

# main function
def main():
    # make function
    make_function()
    pts = np.matrix(plt.ginput(1))
    x = pts[:,0]
    w0 = float(x[0])                        # grab user defined initial pt

    # perform newton's method
    w,w_path,g_path = newtons_method(w0)
    plot_steps_with_surrogate(w_path,g_path)

main()

